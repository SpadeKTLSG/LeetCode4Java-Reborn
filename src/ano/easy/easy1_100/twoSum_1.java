package ano.easy.easy1_100;

public class twoSum_1 {

    class Solution {

        /**
         * 两数之和
         */
        public int[] twoSum(int[] nums, int target) {
            /*给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
            你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素*/

            //? 输入： nums = [3,2,4], target = 6
            //? 输出：[1,2]

            //----

            //坑点解析: 只是整数, 可能有负数, 导致最后不一定是逐渐往上加, 并且最大的元素可能比target还要大. 如果忽略这个性能估计会进一步提升
            //但是绝对要从健壮性出发


            // 个人思路
            //! 由于只需要输出一个可能的解, 并且元素是不能重复使用的
            // 直接取一个, 定死了之后去扫描另一个, 这就是一般想法了. n^2复杂度. for循两层.
            // 优化: 仍然是全扫描, 但是先排序一次, 使用降序排序(系统自带快排). 这样就得到了一个有序的序列了
            // 因为是加法, 并且是越加越多, 直接一口吃最大的一份, 选[0]号元素; 然后判断是不是超过了target.
            // 根据比较结果进行 聪明 判断:
            // if > target: 用一个指针从最小端往回遍历, 直到找到; 如果小于了就报错
            // if < target: 同样用一个指针

            return null;
        }
    }

}
